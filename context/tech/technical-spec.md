# RaceStand — Technical Specification

- **Version:** 0.1 (MVP)
- **Status:** Draft
- **Last Updated:** 2026-02-03

---

## 1. Overview

This document provides the complete technical implementation details for RaceStand v0.1 MVP. It serves as the blueprint for building the single-file HTML application.

---

## 2. File Structure

```
racestand.html
├── <!DOCTYPE html>
├── <head>
│   ├── Meta tags (charset, viewport)
│   ├── Title
│   └── <style> (all CSS)
├── <body>
│   └── <div id="app">
│       ├── <header id="header">
│       ├── <section id="config-panel">
│       ├── <section id="grid-panel">
│       └── <section id="status-panel">
└── <script> (all JavaScript)
```

---

## 3. HTML Structure

### 3.1 Document Head

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RaceStand - Championship Calculator</title>
    <style>
        /* CSS goes here - see Section 4 */
    </style>
</head>
```

### 3.2 Header Section

```html
<header id="header">
    <div class="header-content">
        <h1 class="logo">RaceStand</h1>
        <input type="text"
               id="championship-name"
               placeholder="Championship Name (optional)"
               class="championship-input">
    </div>
</header>
```

### 3.3 Configuration Panel

```html
<section id="config-panel" class="panel">
    <h2 class="panel-title">Championship Settings</h2>

    <div class="config-grid">
        <!-- Scoring Table -->
        <div class="config-item">
            <label for="scoring-input">Points per Position</label>
            <input type="text"
                   id="scoring-input"
                   placeholder="25,18,15,12,10,8,6,4,2,1"
                   class="scoring-input">
            <small class="help-text">Comma-separated (P1, P2, P3...)</small>
        </div>

        <!-- Total Rounds -->
        <div class="config-item">
            <label for="total-rounds">Total Rounds</label>
            <input type="number"
                   id="total-rounds"
                   min="1"
                   max="50"
                   value="5">
        </div>

        <!-- Drop Rounds -->
        <div class="config-item">
            <label for="count-best">Count Best</label>
            <div class="inline-group">
                <input type="number"
                       id="count-best"
                       min="1"
                       max="50"
                       value="5">
                <span class="of-text">of <span id="total-display">5</span></span>
            </div>
        </div>

        <!-- Fastest Lap -->
        <div class="config-item">
            <label class="toggle-label">
                <input type="checkbox" id="fl-enabled">
                <span>Fastest Lap Bonus</span>
            </label>
            <div id="fl-bonus-wrapper" class="hidden">
                <input type="number"
                       id="fl-bonus"
                       min="1"
                       max="10"
                       value="1">
                <span>point(s)</span>
            </div>
        </div>
    </div>
</section>
```

### 3.4 Grid Panel

```html
<section id="grid-panel" class="panel">
    <div class="grid-header">
        <h2 class="panel-title">Results</h2>
        <button id="add-driver-btn" class="btn btn-primary">+ Add Driver</button>
    </div>

    <div class="grid-container">
        <table id="results-grid">
            <thead id="grid-head">
                <!-- Generated by JavaScript -->
            </thead>
            <tbody id="grid-body">
                <!-- Generated by JavaScript -->
            </tbody>
        </table>
    </div>

    <!-- Add Driver Modal -->
    <div id="add-driver-modal" class="modal hidden">
        <div class="modal-content">
            <h3>Add Driver</h3>
            <input type="text"
                   id="new-driver-name"
                   placeholder="Driver name">
            <div class="modal-actions">
                <button id="cancel-add-driver" class="btn btn-secondary">Cancel</button>
                <button id="confirm-add-driver" class="btn btn-primary">Add</button>
            </div>
        </div>
    </div>
</section>
```

### 3.5 Status Panel

```html
<section id="status-panel" class="panel">
    <h2 class="panel-title">Championship Status</h2>

    <div id="status-content">
        <!-- My Driver Status -->
        <div id="my-driver-status" class="status-card">
            <div class="status-header">
                <span id="my-driver-name">-</span>
                <span id="my-driver-points" class="points-badge">0 pts</span>
            </div>
            <div id="status-message" class="status-message">
                Add competitors to begin
            </div>
        </div>

        <!-- Threat Analysis -->
        <div id="threats-section" class="hidden">
            <h3 class="section-title">Rivals</h3>
            <div id="threats-list">
                <!-- Generated by JavaScript -->
            </div>
        </div>

        <!-- What's Needed -->
        <div id="whats-needed" class="hidden">
            <h3 class="section-title">What You Need</h3>
            <div id="needed-message"></div>
        </div>
    </div>
</section>
```

---

## 4. CSS Specification

### 4.1 CSS Variables (Design Tokens)

```css
:root {
    /* Colors */
    --bg-primary: #0a0e17;
    --bg-secondary: #111827;
    --bg-tertiary: #1f2937;
    --bg-card: rgba(255, 255, 255, 0.03);

    --text-primary: #e2e8f0;
    --text-secondary: #94a3b8;
    --text-muted: #64748b;

    --accent: #eab308;
    --accent-dim: rgba(234, 179, 8, 0.15);

    --success: #22c55e;
    --success-dim: rgba(34, 197, 94, 0.15);

    --danger: #ef4444;
    --danger-dim: rgba(239, 68, 68, 0.15);

    --border: rgba(255, 255, 255, 0.06);
    --border-hover: rgba(255, 255, 255, 0.12);

    /* Typography */
    --font-mono: 'JetBrains Mono', 'Fira Code', 'SF Mono', ui-monospace, monospace;
    --font-sans: 'Space Grotesk', system-ui, -apple-system, sans-serif;

    /* Spacing */
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 16px;
    --space-lg: 24px;
    --space-xl: 32px;

    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 8px;
    --radius-lg: 12px;

    /* Transitions */
    --transition-fast: 150ms ease;
    --transition-normal: 250ms ease;
}
```

### 4.2 Base Styles

```css
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px;
}

body {
    font-family: var(--font-mono);
    background: linear-gradient(165deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
    color: var(--text-primary);
    min-height: 100vh;
    line-height: 1.5;
}

#app {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--space-lg);
}

.hidden {
    display: none !important;
}
```

### 4.3 Component Styles

```css
/* Panel */
.panel {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    margin-bottom: var(--space-lg);
}

.panel-title {
    font-family: var(--font-sans);
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-muted);
    margin-bottom: var(--space-md);
}

/* Buttons */
.btn {
    font-family: var(--font-mono);
    font-size: 0.875rem;
    font-weight: 500;
    padding: var(--space-sm) var(--space-md);
    border-radius: var(--radius-md);
    border: 1px solid var(--border);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.btn-primary {
    background: var(--accent-dim);
    border-color: var(--accent);
    color: var(--accent);
}

.btn-primary:hover {
    background: var(--accent);
    color: var(--bg-primary);
}

.btn-secondary {
    background: transparent;
    color: var(--text-secondary);
}

.btn-secondary:hover {
    background: var(--bg-tertiary);
}

/* Inputs */
input[type="text"],
input[type="number"] {
    font-family: var(--font-mono);
    font-size: 0.875rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: var(--space-sm) var(--space-md);
    color: var(--text-primary);
    transition: border-color var(--transition-fast);
}

input:focus {
    outline: none;
    border-color: var(--accent);
}

input::placeholder {
    color: var(--text-muted);
}

/* Grid Table */
#results-grid {
    width: 100%;
    border-collapse: collapse;
}

#results-grid th,
#results-grid td {
    padding: var(--space-sm);
    text-align: center;
    border-bottom: 1px solid var(--border);
}

#results-grid th {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
}

#results-grid td {
    font-size: 0.875rem;
}

/* Driver Name Cell */
.driver-cell {
    text-align: left !important;
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.driver-name {
    flex: 1;
}

.my-driver-marker {
    color: var(--accent);
    cursor: pointer;
}

.delete-driver {
    color: var(--text-muted);
    cursor: pointer;
    opacity: 0;
    transition: opacity var(--transition-fast);
}

tr:hover .delete-driver {
    opacity: 1;
}

.delete-driver:hover {
    color: var(--danger);
}

/* Result Cell */
.result-cell {
    cursor: pointer;
    min-width: 48px;
}

.result-cell:hover {
    background: var(--bg-tertiary);
}

.result-cell.future {
    background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 4px,
        rgba(255, 255, 255, 0.02) 4px,
        rgba(255, 255, 255, 0.02) 8px
    );
}

.result-cell.editing {
    background: var(--accent-dim);
}

.result-input {
    width: 100%;
    text-align: center;
    background: transparent;
    border: none;
    color: var(--text-primary);
    font-size: inherit;
    font-family: inherit;
}

.result-input:focus {
    outline: none;
}

/* FL Checkbox */
.fl-checkbox {
    cursor: pointer;
    accent-color: var(--accent);
}

/* Points/Rank Columns */
.total-cell {
    font-weight: 700;
    color: var(--accent);
}

.rank-cell {
    font-weight: 600;
}

.rank-1 { color: var(--accent); }
.rank-2 { color: var(--text-secondary); }
.rank-3 { color: #cd7f32; }

/* My Driver Row Highlight */
tr.my-driver-row {
    background: var(--accent-dim);
}

/* Status Cards */
.status-card {
    background: var(--bg-tertiary);
    border-radius: var(--radius-md);
    padding: var(--space-md);
    margin-bottom: var(--space-md);
}

.status-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-sm);
}

.points-badge {
    background: var(--accent-dim);
    color: var(--accent);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    font-weight: 600;
}

.status-message {
    font-size: 1.125rem;
    font-weight: 600;
}

.status-guaranteed {
    color: var(--success);
}

.status-leading {
    color: var(--accent);
}

.status-danger {
    color: var(--danger);
}

/* Modal */
.modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
}

.modal-content {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    min-width: 300px;
}

.modal-content h3 {
    margin-bottom: var(--space-md);
}

.modal-content input {
    width: 100%;
    margin-bottom: var(--space-md);
}

.modal-actions {
    display: flex;
    gap: var(--space-sm);
    justify-content: flex-end;
}
```

### 4.4 Responsive Styles

```css
@media (max-width: 768px) {
    #app {
        padding: var(--space-md);
    }

    .panel {
        padding: var(--space-md);
    }

    .config-grid {
        grid-template-columns: 1fr;
    }

    .grid-container {
        overflow-x: auto;
    }

    #results-grid {
        min-width: 600px;
    }
}
```

---

## 5. JavaScript Specification

### 5.1 State Management

```javascript
// Global state object - single source of truth
const state = {
    championship: {
        name: '',
        scoring: [25, 18, 15, 12, 10, 8, 6, 4, 2, 1],
        totalRounds: 5,
        countBest: 5,
        flEnabled: false,
        flBonus: 1
    },
    competitors: [],
    ui: {
        editingCell: null  // { competitorId, raceIndex }
    }
};

// Generate unique ID
function generateId() {
    return 'comp_' + Math.random().toString(36).substr(2, 9);
}
```

### 5.2 State Actions

```javascript
// Update championship config
function updateConfig(updates) {
    Object.assign(state.championship, updates);

    // Ensure countBest <= totalRounds
    if (state.championship.countBest > state.championship.totalRounds) {
        state.championship.countBest = state.championship.totalRounds;
    }

    // Resize competitor results arrays
    state.competitors.forEach(comp => {
        while (comp.results.length < state.championship.totalRounds) {
            comp.results.push({ position: null, fastestLap: false });
        }
        comp.results.length = state.championship.totalRounds;
    });

    render();
}

// Add competitor
function addCompetitor(name) {
    const trimmedName = name.trim();

    // Validation
    if (!trimmedName) return { error: 'Name cannot be empty' };

    const exists = state.competitors.some(
        c => c.name.toLowerCase() === trimmedName.toLowerCase()
    );
    if (exists) return { error: 'Driver already exists' };

    const competitor = {
        id: generateId(),
        name: trimmedName,
        isMyDriver: state.competitors.length === 0, // First driver is "my driver"
        results: Array(state.championship.totalRounds).fill(null).map(() => ({
            position: null,
            fastestLap: false
        }))
    };

    state.competitors.push(competitor);
    render();
    return { success: true };
}

// Remove competitor
function removeCompetitor(id) {
    if (state.competitors.length <= 2) {
        return { error: 'Minimum 2 drivers required' };
    }

    const index = state.competitors.findIndex(c => c.id === id);
    if (index === -1) return { error: 'Driver not found' };

    const wasMyDriver = state.competitors[index].isMyDriver;
    state.competitors.splice(index, 1);

    // Reassign "my driver" if needed
    if (wasMyDriver && state.competitors.length > 0) {
        state.competitors[0].isMyDriver = true;
    }

    render();
    return { success: true };
}

// Set "my driver"
function setMyDriver(id) {
    state.competitors.forEach(c => {
        c.isMyDriver = c.id === id;
    });
    render();
}

// Set race result
function setResult(competitorId, raceIndex, position) {
    const competitor = state.competitors.find(c => c.id === competitorId);
    if (!competitor) return;

    // Parse and validate
    const pos = position === '' || position === null ? null : parseInt(position, 10);

    if (pos !== null && (isNaN(pos) || pos < 1)) {
        return { error: 'Invalid position' };
    }

    competitor.results[raceIndex].position = pos;
    render();
    return { success: true };
}

// Set fastest lap
function setFastestLap(competitorId, raceIndex, hasFl) {
    // Remove FL from other drivers in same race
    if (hasFl) {
        state.competitors.forEach(c => {
            if (c.results[raceIndex]) {
                c.results[raceIndex].fastestLap = false;
            }
        });
    }

    const competitor = state.competitors.find(c => c.id === competitorId);
    if (competitor && competitor.results[raceIndex]) {
        competitor.results[raceIndex].fastestLap = hasFl;
    }

    render();
}
```

### 5.3 Calculation Functions

```javascript
// Calculate points for a single race
function calculateRacePoints(position, hasFastestLap) {
    if (position === null || position === undefined) return 0;

    const { scoring, flEnabled, flBonus } = state.championship;
    const positionPoints = scoring[position - 1] || 0;
    const flPoints = (flEnabled && hasFastestLap) ? flBonus : 0;

    return positionPoints + flPoints;
}

// Calculate total points with drop rounds
function calculateTotalPoints(results) {
    const { countBest } = state.championship;

    const racePoints = results.map(r =>
        calculateRacePoints(r.position, r.fastestLap)
    );

    // Sort descending and take best N
    const sorted = [...racePoints].sort((a, b) => b - a);
    const best = sorted.slice(0, countBest);

    return best.reduce((sum, pts) => sum + pts, 0);
}

// Count position finishes (for tiebreaker)
function countPositionFinishes(results, position) {
    return results.filter(r => r.position === position).length;
}

// Calculate standings for all competitors
function calculateStandings() {
    const standings = state.competitors.map(comp => {
        const totalPoints = calculateTotalPoints(comp.results);
        const wins = countPositionFinishes(comp.results, 1);

        return {
            competitorId: comp.id,
            name: comp.name,
            isMyDriver: comp.isMyDriver,
            totalPoints,
            wins,
            results: comp.results
        };
    });

    // Sort by points, then tiebreakers
    standings.sort((a, b) => {
        if (b.totalPoints !== a.totalPoints) {
            return b.totalPoints - a.totalPoints;
        }

        // Tiebreaker: count finishes from P1 down
        for (let pos = 1; pos <= 20; pos++) {
            const aCount = countPositionFinishes(a.results, pos);
            const bCount = countPositionFinishes(b.results, pos);
            if (bCount !== aCount) return bCount - aCount;
        }

        // Final tiebreaker: alphabetical
        return a.name.localeCompare(b.name);
    });

    // Assign ranks (handling ties)
    let currentRank = 1;
    standings.forEach((standing, index) => {
        if (index > 0) {
            const prev = standings[index - 1];
            const isTied = standing.totalPoints === prev.totalPoints &&
                          standing.wins === prev.wins;
            if (!isTied) {
                currentRank = index + 1;
            }
        }
        standing.rank = currentRank;
        standing.isTied = index > 0 && standing.rank === standings[index - 1].rank;
    });

    return standings;
}

// Calculate maximum possible points for a competitor
function calculateMaxPossiblePoints(competitor) {
    const { scoring, totalRounds, countBest, flEnabled, flBonus } = state.championship;
    const maxRacePoints = (scoring[0] || 0) + (flEnabled ? flBonus : 0);

    // Current points from completed races
    const currentPoints = competitor.results.map(r =>
        calculateRacePoints(r.position, r.fastestLap)
    );

    // Count remaining races (no result entered)
    const remainingRaces = competitor.results.filter(r => r.position === null).length;

    // Add max points for remaining races
    const allPoints = [...currentPoints];
    for (let i = 0; i < remainingRaces; i++) {
        const emptyIndex = allPoints.findIndex(p => p === 0 &&
            competitor.results[allPoints.indexOf(p)]?.position === null);
        if (emptyIndex !== -1) {
            allPoints[emptyIndex] = maxRacePoints;
        } else {
            allPoints.push(maxRacePoints);
        }
    }

    // Calculate max with drops
    const sorted = [...allPoints].sort((a, b) => b - a);
    return sorted.slice(0, countBest).reduce((sum, p) => sum + p, 0);
}

// Calculate championship status for "my driver"
function calculateChampionshipStatus() {
    const myDriver = state.competitors.find(c => c.isMyDriver);
    if (!myDriver || state.competitors.length < 2) {
        return { status: 'NONE', message: 'Add competitors to begin' };
    }

    const standings = calculateStandings();
    const myStanding = standings.find(s => s.competitorId === myDriver.id);
    const myPoints = myStanding.totalPoints;
    const myRank = myStanding.rank;
    const myMaxPoints = calculateMaxPossiblePoints(myDriver);

    // Find threats (competitors who can still catch my driver)
    const threats = state.competitors
        .filter(c => c.id !== myDriver.id)
        .map(rival => {
            const rivalStanding = standings.find(s => s.competitorId === rival.id);
            const rivalMax = calculateMaxPossiblePoints(rival);
            return {
                name: rival.name,
                currentPoints: rivalStanding.totalPoints,
                maxPoints: rivalMax,
                canCatch: rivalMax >= myPoints
            };
        })
        .filter(t => t.canCatch)
        .sort((a, b) => b.maxPoints - a.maxPoints);

    // Find leader if not my driver
    const leader = standings[0];
    const leaderMax = leader.competitorId !== myDriver.id
        ? calculateMaxPossiblePoints(state.competitors.find(c => c.id === leader.competitorId))
        : myMaxPoints;

    // Determine status
    let status, message;

    if (myRank === 1 && threats.length === 0) {
        status = 'GUARANTEED';
        message = `TITLE GUARANTEED! No one can catch you.`;
    } else if (myRank === 1 && threats.every(t => t.maxPoints < myPoints)) {
        status = 'GUARANTEED';
        const gap = myPoints - Math.max(...threats.map(t => t.maxPoints));
        message = `TITLE GUARANTEED! +${gap} points ahead.`;
    } else if (myRank === 1) {
        status = 'LEADING';
        const topThreat = threats[0];
        const gap = myPoints - topThreat.currentPoints;
        message = `Leading by ${gap} points. ${topThreat.name} can still catch you.`;
    } else if (myMaxPoints >= leader.totalPoints) {
        status = 'POSSIBLE';
        const gap = leader.totalPoints - myPoints;
        message = `${gap} points behind ${leader.name}. Title still possible.`;
    } else {
        status = 'ELIMINATED';
        message = `Cannot win championship. Max possible: ${myMaxPoints} points.`;
    }

    return { status, message, threats, myPoints, myRank, myMaxPoints };
}

// Determine if a race is "completed" (any result entered)
function isRaceCompleted(raceIndex) {
    return state.competitors.some(c =>
        c.results[raceIndex] && c.results[raceIndex].position !== null
    );
}
```

### 5.4 Render Functions

```javascript
// Main render function
function render() {
    renderConfig();
    renderGrid();
    renderStatus();
}

// Render configuration panel
function renderConfig() {
    const { scoring, totalRounds, countBest, flEnabled, flBonus, name } = state.championship;

    document.getElementById('championship-name').value = name;
    document.getElementById('scoring-input').value = scoring.join(',');
    document.getElementById('total-rounds').value = totalRounds;
    document.getElementById('count-best').value = countBest;
    document.getElementById('total-display').textContent = totalRounds;
    document.getElementById('fl-enabled').checked = flEnabled;
    document.getElementById('fl-bonus').value = flBonus;

    const flBonusWrapper = document.getElementById('fl-bonus-wrapper');
    flBonusWrapper.classList.toggle('hidden', !flEnabled);
}

// Render results grid
function renderGrid() {
    const { totalRounds, flEnabled } = state.championship;
    const standings = calculateStandings();

    // Render header
    const thead = document.getElementById('grid-head');
    let headerHtml = '<tr><th class="driver-header">Driver</th>';

    for (let i = 0; i < totalRounds; i++) {
        const isCompleted = isRaceCompleted(i);
        const headerClass = isCompleted ? '' : 'future-header';
        headerHtml += `<th class="${headerClass}">R${i + 1}</th>`;
        if (flEnabled) {
            headerHtml += `<th class="${headerClass} fl-header">FL</th>`;
        }
    }

    headerHtml += '<th>Total</th><th>Rank</th></tr>';
    thead.innerHTML = headerHtml;

    // Render body
    const tbody = document.getElementById('grid-body');
    let bodyHtml = '';

    standings.forEach(standing => {
        const competitor = state.competitors.find(c => c.id === standing.competitorId);
        const rowClass = competitor.isMyDriver ? 'my-driver-row' : '';

        bodyHtml += `<tr class="${rowClass}" data-id="${competitor.id}">`;

        // Driver cell
        bodyHtml += `
            <td class="driver-cell">
                <span class="my-driver-marker" onclick="setMyDriver('${competitor.id}')" title="Mark as my driver">
                    ${competitor.isMyDriver ? '★' : '☆'}
                </span>
                <span class="driver-name">${escapeHtml(competitor.name)}</span>
                <span class="delete-driver" onclick="confirmRemoveCompetitor('${competitor.id}')" title="Remove driver">×</span>
            </td>
        `;

        // Race result cells
        for (let i = 0; i < totalRounds; i++) {
            const result = competitor.results[i];
            const isCompleted = isRaceCompleted(i);
            const cellClass = isCompleted ? 'result-cell' : 'result-cell future';
            const displayValue = result.position !== null ? result.position : '';
            const points = calculateRacePoints(result.position, result.fastestLap);
            const tooltip = result.position !== null ? `${points} points` : 'Click to enter position';

            bodyHtml += `
                <td class="${cellClass}"
                    onclick="startEditCell('${competitor.id}', ${i})"
                    title="${tooltip}">
                    ${displayValue}
                </td>
            `;

            if (flEnabled) {
                const checked = result.fastestLap ? 'checked' : '';
                bodyHtml += `
                    <td class="fl-cell">
                        <input type="checkbox"
                               class="fl-checkbox"
                               ${checked}
                               onchange="setFastestLap('${competitor.id}', ${i}, this.checked)">
                    </td>
                `;
            }
        }

        // Total and rank
        const rankClass = `rank-cell rank-${standing.rank}`;
        const rankDisplay = standing.isTied ? `T${standing.rank}` : standing.rank;

        bodyHtml += `
            <td class="total-cell">${standing.totalPoints}</td>
            <td class="${rankClass}">${rankDisplay}</td>
        </tr>`;
    });

    tbody.innerHTML = bodyHtml;
}

// Render status panel
function renderStatus() {
    const status = calculateChampionshipStatus();

    const myDriverName = document.getElementById('my-driver-name');
    const myDriverPoints = document.getElementById('my-driver-points');
    const statusMessage = document.getElementById('status-message');
    const threatsSection = document.getElementById('threats-section');
    const threatsList = document.getElementById('threats-list');

    const myDriver = state.competitors.find(c => c.isMyDriver);

    if (!myDriver) {
        myDriverName.textContent = '-';
        myDriverPoints.textContent = '0 pts';
        statusMessage.textContent = 'Add competitors to begin';
        statusMessage.className = 'status-message';
        threatsSection.classList.add('hidden');
        return;
    }

    myDriverName.textContent = myDriver.name;
    myDriverPoints.textContent = `${status.myPoints} pts`;
    statusMessage.textContent = status.message;

    // Status styling
    let statusClass = 'status-message ';
    switch (status.status) {
        case 'GUARANTEED':
            statusClass += 'status-guaranteed';
            break;
        case 'LEADING':
            statusClass += 'status-leading';
            break;
        case 'ELIMINATED':
        case 'POSSIBLE':
            statusClass += 'status-danger';
            break;
    }
    statusMessage.className = statusClass;

    // Threats
    if (status.threats && status.threats.length > 0) {
        threatsSection.classList.remove('hidden');
        threatsList.innerHTML = status.threats.map(t => `
            <div class="threat-item">
                <span class="threat-name">${escapeHtml(t.name)}</span>
                <span class="threat-points">${t.currentPoints} pts (max: ${t.maxPoints})</span>
            </div>
        `).join('');
    } else {
        threatsSection.classList.add('hidden');
    }
}

// Utility: escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
```

### 5.5 Event Handlers

```javascript
// Initialize event listeners
function initEventListeners() {
    // Championship name
    document.getElementById('championship-name').addEventListener('input', (e) => {
        state.championship.name = e.target.value;
    });

    // Scoring input
    document.getElementById('scoring-input').addEventListener('change', (e) => {
        const input = e.target.value;
        const values = input.split(',')
            .map(v => parseInt(v.trim(), 10))
            .filter(v => !isNaN(v) && v >= 0);

        if (values.length > 0) {
            updateConfig({ scoring: values });
        }
    });

    // Total rounds
    document.getElementById('total-rounds').addEventListener('change', (e) => {
        const value = parseInt(e.target.value, 10);
        if (value >= 1 && value <= 50) {
            updateConfig({ totalRounds: value });
        }
    });

    // Count best
    document.getElementById('count-best').addEventListener('change', (e) => {
        const value = parseInt(e.target.value, 10);
        if (value >= 1 && value <= state.championship.totalRounds) {
            updateConfig({ countBest: value });
        }
    });

    // Fastest lap toggle
    document.getElementById('fl-enabled').addEventListener('change', (e) => {
        updateConfig({ flEnabled: e.target.checked });
    });

    // FL bonus value
    document.getElementById('fl-bonus').addEventListener('change', (e) => {
        const value = parseInt(e.target.value, 10);
        if (value >= 1 && value <= 10) {
            updateConfig({ flBonus: value });
        }
    });

    // Add driver button
    document.getElementById('add-driver-btn').addEventListener('click', showAddDriverModal);

    // Modal buttons
    document.getElementById('cancel-add-driver').addEventListener('click', hideAddDriverModal);
    document.getElementById('confirm-add-driver').addEventListener('click', confirmAddDriver);

    // Enter key in driver name input
    document.getElementById('new-driver-name').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            confirmAddDriver();
        }
    });

    // Click outside modal to close
    document.getElementById('add-driver-modal').addEventListener('click', (e) => {
        if (e.target.id === 'add-driver-modal') {
            hideAddDriverModal();
        }
    });

    // Global keyboard handler for grid editing
    document.addEventListener('keydown', handleGridKeydown);
}

// Show add driver modal
function showAddDriverModal() {
    document.getElementById('add-driver-modal').classList.remove('hidden');
    document.getElementById('new-driver-name').value = '';
    document.getElementById('new-driver-name').focus();
}

// Hide add driver modal
function hideAddDriverModal() {
    document.getElementById('add-driver-modal').classList.add('hidden');
}

// Confirm add driver
function confirmAddDriver() {
    const name = document.getElementById('new-driver-name').value;
    const result = addCompetitor(name);

    if (result.error) {
        alert(result.error);
    } else {
        hideAddDriverModal();
    }
}

// Confirm remove competitor
function confirmRemoveCompetitor(id) {
    const competitor = state.competitors.find(c => c.id === id);
    if (!competitor) return;

    if (confirm(`Remove ${competitor.name} and all their results?`)) {
        const result = removeCompetitor(id);
        if (result.error) {
            alert(result.error);
        }
    }
}

// Start editing a result cell
function startEditCell(competitorId, raceIndex) {
    state.ui.editingCell = { competitorId, raceIndex };

    const competitor = state.competitors.find(c => c.id === competitorId);
    const currentValue = competitor.results[raceIndex].position;

    // Find the cell and replace with input
    const row = document.querySelector(`tr[data-id="${competitorId}"]`);
    const cells = row.querySelectorAll('.result-cell');
    const cell = cells[raceIndex];

    cell.classList.add('editing');
    cell.innerHTML = `
        <input type="number"
               class="result-input"
               value="${currentValue || ''}"
               min="1"
               onblur="finishEditCell()"
               id="editing-input">
    `;

    const input = document.getElementById('editing-input');
    input.focus();
    input.select();
}

// Finish editing cell
function finishEditCell() {
    if (!state.ui.editingCell) return;

    const input = document.getElementById('editing-input');
    if (!input) return;

    const { competitorId, raceIndex } = state.ui.editingCell;
    const value = input.value;

    setResult(competitorId, raceIndex, value);
    state.ui.editingCell = null;
}

// Handle keyboard navigation in grid
function handleGridKeydown(e) {
    if (!state.ui.editingCell) return;

    const input = document.getElementById('editing-input');
    if (!input) return;

    if (e.key === 'Enter' || e.key === 'Tab') {
        e.preventDefault();
        finishEditCell();

        // Move to next cell
        const { competitorId, raceIndex } = state.ui.editingCell || {};
        if (e.key === 'Tab') {
            const nextRace = raceIndex + 1;
            if (nextRace < state.championship.totalRounds) {
                setTimeout(() => startEditCell(competitorId, nextRace), 0);
            }
        }
    } else if (e.key === 'Escape') {
        state.ui.editingCell = null;
        render();
    }
}
```

### 5.6 Initialization

```javascript
// Initialize application
function init() {
    // Add default competitors for demo
    addCompetitor('Driver 1');
    addCompetitor('Driver 2');

    initEventListeners();
    render();
}

// Start when DOM is ready
document.addEventListener('DOMContentLoaded', init);
```

---

## 6. Testing Checklist

### 6.1 Configuration Tests

- [ ] Scoring table parses comma-separated values correctly
- [ ] Scoring table handles whitespace around values
- [ ] Invalid scoring values show error
- [ ] Total rounds adjusts grid columns
- [ ] Count best cannot exceed total rounds
- [ ] FL toggle shows/hides bonus input

### 6.2 Competitor Tests

- [ ] Add driver creates new row
- [ ] Empty name shows error
- [ ] Duplicate name shows error
- [ ] Remove driver prompts confirmation
- [ ] Cannot remove below 2 drivers
- [ ] My driver star toggles correctly
- [ ] Removing my driver reassigns to another

### 6.3 Results Grid Tests

- [ ] Click cell starts editing
- [ ] Enter position saves value
- [ ] Empty input clears position (DNF)
- [ ] Tab moves to next cell
- [ ] Escape cancels edit
- [ ] FL checkbox toggles correctly
- [ ] Only one FL per race enforced
- [ ] Future races have different styling

### 6.4 Calculation Tests

- [ ] Points calculate correctly from scoring table
- [ ] FL bonus adds to race points
- [ ] Drop rounds calculate best N
- [ ] Standings sort by points
- [ ] Tiebreaker uses wins then P2s etc
- [ ] Tied ranks display with T prefix
- [ ] Championship status shows correctly

### 6.5 Status Tests

- [ ] GUARANTEED shows when can't be caught
- [ ] LEADING shows gap and top threat
- [ ] POSSIBLE shows when can still win
- [ ] ELIMINATED shows max possible points
- [ ] Threats list shows catchable rivals

### 6.6 Edge Case Tests

- [ ] All drivers DNF = all 0 points
- [ ] Position beyond scoring table = 0 points
- [ ] Single race with drops = drops ignored
- [ ] All races completed = no future cells
- [ ] 50 drivers × 50 races renders reasonably

---

## 7. File Size Budget

| Section | Target | Notes |
|---------|--------|-------|
| HTML structure | ~3KB | Semantic, minimal nesting |
| CSS | ~10KB | Efficient selectors, CSS variables |
| JavaScript | ~20KB | No comments in production |
| **Total** | **<35KB** | Unminified, uncompressed |

---

## 8. Browser Testing Matrix

| Browser | Version | Priority |
|---------|---------|----------|
| Chrome | Latest | P0 |
| Firefox | Latest | P0 |
| Safari | Latest | P1 |
| Edge | Latest | P1 |
| Chrome Mobile | Latest | P1 |
| Safari iOS | Latest | P1 |
